package struct_to_map

import (
	"bytes"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"strings"
	"text/template"

	"github.com/nan-www/convToMap/ps"
)

const genTemplate = `// Code generated by convToMap. DO NOT EDIT !!!

package {{.PackageName}}

{{range .Structs}}
// ToStringMap converts the {{.Name}} struct to a map[string]any.
func (s *{{.Name}}) ToStringMap() map[string]any {
    m := make(map[string]any)
    {{range .Fields}} // <-- 字段循环开始
		{{if .IsPtrObj}}
		if s.{{.Name}} != nil {
			m["{{.TagName}}"] = s.{{.Name}}.ToStringMap()
		}
		{{else if .IsObj}}
		m["{{.TagName}}"] = s.{{.Name}}.ToStringMap()
		{{else if .IsPtr}}
		if s.{{.Name}} != nil {
			m["{{.TagName}}"] = s.{{.Name}}
		}
		{{else}}
			{{if eq .Type "string"}}
			if s.{{.Name}} != "" {
				m["{{.TagName}}"] = s.{{.Name}}
			}
			{{else if or (eq .Type "int") (eq .Type "int32") (eq .Type "int64") (eq .Type "float64") (eq .Type "float32")}}
			if s.{{.Name}} != 0 {
				m["{{.TagName}}"] = s.{{.Name}}
			}
			{{else}}
			m["{{.TagName}}"] = s.{{.Name}}
			{{end}}
		{{end}}
    {{end}} // <-- 错误修复 1：在这里关闭 'range .Fields' 循环

    return m // <-- 错误修复 2：'return' 语句必须在循环之外
}
{{end}}
`

// func (s *{{.Name}}) _2Struct(str2Any map[string]any)  {
// {{range .Fields}}
// {{if .IsPtrObj}}
// if val, ok := str2Any["{{.TagName}}"]; ok {
// s.{{.Name}} = &{{.Type}}{}
// s.{{.Name}}._2Struct(val.(map[string]any))
// }
// {{else if .IsObj}}
// if val, ok := str2Any["{{.TagName}}"]; ok {
// s.{{.Name}} = {{.Type}}{}
// s.{{.Name}}._2Struct(val.(map[string]any))
// }
// {{else}}
// if val, ok := str2Any["{{.TagName}}"]; ok {
// s.{{.Name}} = val.({{.Type}})
// }
// {{end}}
// {{end}}
// }
func GenStruct2MapFile(filename string) {
	// 设置要查找的特定 go:generate 标识
	const tag = "//go:generate convToMap"

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing file %s: %v\n", filename, err)
		os.Exit(1)
	}
	data := ps.ParseMarkStruct(node)
	if len(data.Structs) == 0 {
		fmt.Fprintf(os.Stderr, "No struct found with %s", tag)
		return
	}

	var buf bytes.Buffer
	t := template.Must(template.New("generator").Parse(genTemplate))
	if err := t.Execute(&buf, data); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting generated code: %v\nCode:\n%s\n", err, buf.String())
		os.Exit(1)
	}

	// 输出文件名：命名为 inputFileName_generated.go
	outputFilename := strings.TrimSuffix(filename, ".go") + "_generated.go"
	if err := os.WriteFile(outputFilename, formattedCode, fs.FileMode(0644)); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated code for %d struct(s) in %s\n", len(data.Structs), outputFilename)
}
