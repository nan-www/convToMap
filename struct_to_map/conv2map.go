package struct_to_map

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"strings"
	"text/template"
)

type TemplateData struct {
	PackageName string
	Structs     []Struct
}

type Struct struct {
	Name   string
	Fields []Field
}

type Field struct {
	Name    string
	TagName string // 用于 map 的键名，通常是 JSON tag
}

const genTemplate = `// Code generated by convToMap. DO NOT EDIT.

package {{.PackageName}}

{{range .Structs}}
// ToMap converts the {{.Name}} struct to a map[string]any.
func (s *{{.Name}}) ToMap() map[string]any {
	m := make(map[string]any)
	
	{{range .Fields}}
	m["{{.TagName}}"] = s.{{.Name}}
	{{end}}

	return m
}
{{end}}
`

func GenStruct2MapFile(filename string) {
	// 设置要查找的特定 go:generate 标识
	const tag = "//go:generate convToMap"

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing file %s: %v\n", filename, err)
		os.Exit(1)
	}

	data := TemplateData{
		PackageName: node.Name.Name,
		Structs:     []Struct{},
	}

	ast.Inspect(node, func(n ast.Node) bool {
		genDecl, ok := n.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE || genDecl.Doc == nil {
			return true
		}

		foundGenerate := false
		for _, comment := range genDecl.Doc.List {
			if strings.Contains(comment.Text, tag) {
				foundGenerate = true
				break
			}
		}
		if !foundGenerate {
			return true
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}
			currentStruct := Struct{
				Name:   typeSpec.Name.Name,
				Fields: []Field{},
			}

			for _, field := range structType.Fields.List {
				// inline 字段处理
				if len(field.Names) == 0 {

				}

				fieldName := field.Names[0].Name
				tagName := fieldName // 默认使用字段名

				// 尝试解析 tag
				if field.Tag != nil {
					// field.Tag.Value 是带有反引号的字符串，需要解析
					// 例如：`json:"id,omitempty"`
					tagString := strings.Trim(field.Tag.Value, "`")

					// 使用 reflect.StructTag 模拟解析
					// 为了简单起见，我们直接查找 json tag
					if tag, found := reflectTag(tagString, "json"); found {
						// 忽略 ,omitempty 或其他选项
						tagName = strings.Split(tag, ",")[0]
						// 忽略 tag 中 "-" 的字段
						if tagName == "-" {
							continue
						}
					}
				}

				currentStruct.Fields = append(currentStruct.Fields, Field{
					Name:    fieldName,
					TagName: tagName,
				})
			}

			data.Structs = append(data.Structs, currentStruct)
		}

		return false
	})

	if len(data.Structs) == 0 {
		fmt.Fprintf(os.Stderr, "No struct found with %s", tag)
		return
	}

	var buf bytes.Buffer
	t := template.Must(template.New("generator").Parse(genTemplate))
	if err := t.Execute(&buf, data); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting generated code: %v\nCode:\n%s\n", err, buf.String())
		os.Exit(1)
	}

	// 输出文件名：命名为 inputFileName_generated.go
	outputFilename := strings.TrimSuffix(filename, ".go") + "_generated.go"
	if err := os.WriteFile(outputFilename, formattedCode, fs.FileMode(0644)); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated code for %d struct(s) in %s\n", len(data.Structs), outputFilename)
}

func reflectTag(tagString, key string) (string, bool) {
	parts := strings.FieldsFunc(tagString, func(r rune) bool {
		return r == ' '
	})
	for _, part := range parts {
		if strings.HasPrefix(part, key+":") {
			// 找到 'json:"value"'，提取 value 部分
			value := strings.TrimPrefix(part, key+":")
			if len(value) > 1 && value[0] == '"' && value[len(value)-1] == '"' {
				return value[1 : len(value)-1], true
			}
		}
	}
	return "", false
}
