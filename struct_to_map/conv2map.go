package struct_to_map

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// 模板数据结构
type TemplateData struct {
	PackageName string
	Structs     []Struct
}

// 结构体信息
type Struct struct {
	Name   string
	Fields []Field
}

// 字段信息
type Field struct {
	Name    string
	TagName string // 用于 map 的键名，通常是 JSON tag
}

// Go 模板用于生成代码
const genTemplate = `// Code generated by struct-to-map-gen. DO NOT EDIT.

package {{.PackageName}}

import "reflect"

{{range .Structs}}
// ToMap converts the {{.Name}} struct to a map[string]any.
func (s *{{.Name}}) ToMap() map[string]any {
	m := make(map[string]any)
	
	{{range .Fields}}
	m["{{.TagName}}"] = s.{{.Name}}
	{{end}}

	return m
}
{{end}}
`

func GenStruct2MapFile() {
	// 期望 go generate 传递要处理的文件名
	if len(os.Args) < 2 {
		// 常见错误：没有传递文件名
		fmt.Fprintf(os.Stderr, "Usage: %s <filename.go>\n", filepath.Base(os.Args[0]))
		os.Exit(1)
	}

	filename := os.Args[1]

	// 设置要查找的特定 go:generate 标识
	const tag = "//go:generate conv2map"

	// 1. 解析文件
	fset := token.NewFileSet()
	// 必须包含 parser.ParseComments
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing file %s: %v\n", filename, err)
		os.Exit(1)
	}

	data := TemplateData{
		PackageName: node.Name.Name,
		Structs:     []Struct{},
	}

	// 2. 遍历 AST
	ast.Inspect(node, func(n ast.Node) bool {
		genDecl, ok := n.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE || genDecl.Doc == nil {
			return true // 仅处理带有文档注释的类型声明
		}

		// 检查 GenDecl 的文档注释是否包含目标 tag
		foundGenerate := false
		for _, comment := range genDecl.Doc.List {
			if strings.Contains(comment.Text, tag) {
				foundGenerate = true
				break
			}
		}
		if !foundGenerate {
			return true
		}

		// 3. 提取结构体信息
		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue // 目标类型不是结构体
			}

			currentStruct := Struct{
				Name:   typeSpec.Name.Name,
				Fields: []Field{},
			}

			// 提取字段信息，使用 `json` tag 作为 map 的键名
			for _, field := range structType.Fields.List {
				// 忽略没有名称的字段 (例如嵌入的结构体)
				if len(field.Names) == 0 {
					continue
				}

				fieldName := field.Names[0].Name
				tagName := fieldName // 默认使用字段名

				// 尝试解析 tag
				if field.Tag != nil {
					// field.Tag.Value 是带有反引号的字符串，需要解析
					// 例如：`json:"id,omitempty"`
					tagString := strings.Trim(field.Tag.Value, "`")

					// 使用 reflect.StructTag 模拟解析
					// 为了简单起见，我们直接查找 json tag
					if tag, found := reflectTag(tagString, "json"); found {
						// 忽略 ,omitempty 或其他选项
						tagName = strings.Split(tag, ",")[0]
						// 忽略 tag 中 "-" 的字段
						if tagName == "-" {
							continue
						}
					}
				}

				currentStruct.Fields = append(currentStruct.Fields, Field{
					Name:    fieldName,
					TagName: tagName,
				})
			}

			data.Structs = append(data.Structs, currentStruct)
		}

		return false // 停止对当前 GenDecl 的深入遍历
	})

	// 4. 生成代码
	if len(data.Structs) == 0 {
		return // 没有找到需要生成的结构体
	}

	var buf bytes.Buffer
	t := template.Must(template.New("generator").Parse(genTemplate))
	if err := t.Execute(&buf, data); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	// 5. 格式化和写入文件
	// 使用 go/format 格式化代码
	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		// 打印错误代码方便调试
		fmt.Fprintf(os.Stderr, "Error formatting generated code: %v\nCode:\n%s\n", err, buf.String())
		os.Exit(1)
	}

	// 输出文件名：与输入文件同目录，命名为 inputFileName_generated.go
	outputFilename := strings.TrimSuffix(filename, ".go") + "_generated.go"
	if err := os.WriteFile(outputFilename, formattedCode, fs.FileMode(0644)); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated code for %d struct(s) in %s\n", len(data.Structs), outputFilename)
}

// 辅助函数：简化版 tag 解析，因为我们不能直接导入 reflect 包
func reflectTag(tagString, key string) (string, bool) {
	parts := strings.FieldsFunc(tagString, func(r rune) bool {
		return r == ' '
	})
	for _, part := range parts {
		if strings.HasPrefix(part, key+":") {
			// 找到 'json:"value"'，提取 value 部分
			value := strings.TrimPrefix(part, key+":")
			if len(value) > 1 && value[0] == '"' && value[len(value)-1] == '"' {
				return value[1 : len(value)-1], true
			}
		}
	}
	return "", false
}
